'use strict';

exports.__esModule = true;

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports['default'] = createReduxForm;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _actions = require('./actions');

var formActions = _interopRequireWildcard(_actions);

var _getDisplayName = require('./getDisplayName');

var _getDisplayName2 = _interopRequireDefault(_getDisplayName);

var _isPristine = require('./isPristine');

var _isPristine2 = _interopRequireDefault(_isPristine);

var _isValid = require('./isValid');

var _isValid2 = _interopRequireDefault(_isValid);

var _bindActionData = require('./bindActionData');

var _bindActionData2 = _interopRequireDefault(_bindActionData);

var _reducer = require('./reducer');

function isReadonly(prop) {
  var writeProps = ['asyncValidate', 'handleBlur', 'handleChange', 'handleFocus', 'handleSubmit', 'onBlur', 'onChange', 'onFocus'];
  return ! ~writeProps.indexOf(prop);
}

function getSubForm(form, formName, formKey) {
  if (form && form[formName]) {
    if (formKey) {
      if (form[formName][formKey]) {
        return form[formName][formKey];
      }
    } else {
      return form[formName];
    }
  }
  return _reducer.initialState;
}

function silenceEvents(fn) {
  return function (event) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (event && event.preventDefault) {
      event.preventDefault();
      event.stopPropagation();
      return fn.apply(undefined, args);
    }
    return fn.apply(undefined, [event].concat(args));
  };
}

function isAsyncValid(errors) {
  return !errors || Object.keys(errors).reduce(function (valid, error) {
    return valid && _isValid2['default'](errors[error]);
  }, true);
}

function createReduxForm(isReactNative, React) {
  var Component = React.Component;
  var PropTypes = React.PropTypes;

  function getValue(passedValue, event) {
    if (passedValue !== undefined || !event) {
      // extract value from { value: value } structure. https://github.com/nikgraf/belle/issues/58
      return typeof passedValue === 'object' && passedValue.value ? passedValue.value : passedValue;
    }
    if (!isReactNative && event.nativeEvent !== undefined && event.nativeEvent.text !== undefined) {
      return event.nativeEvent.text;
    }
    if (isReactNative && event.nativeEvent !== undefined) {
      return event.nativeEvent.text;
    }
    if (event.target === undefined) {
      // is it a value instead of an event?
      return event;
    }
    var _event$target = event.target;
    var type = _event$target.type;
    var value = _event$target.value;
    var checked = _event$target.checked;
    var files = _event$target.files;
    var dataTransfer = event.dataTransfer;

    if (type === 'checkbox') {
      return checked;
    }
    if (type === 'file') {
      return files || dataTransfer && dataTransfer.files;
    }
    return value;
  }

  return function reduxForm(config) {
    var _extends6 = _extends({
      validate: function validate() {
        return {};
      },
      touchOnBlur: true,
      touchOnChange: false,
      readonly: false,
      asyncValidate: null,
      asyncBlurFields: []
    }, config);

    var formName = _extends6.form;
    var fields = _extends6.fields;
    var syncValidate = _extends6.validate;
    var readonly = _extends6.readonly;
    var touchOnBlur = _extends6.touchOnBlur;
    var touchOnChange = _extends6.touchOnChange;
    var asyncValidate = _extends6.asyncValidate;
    var asyncBlurFields = _extends6.asyncBlurFields;

    if (!fields || !fields.length) {
      throw new Error('No fields passed to redux-form. Must be passed to ' + 'connectReduxForm({fields: ["my", "field", "names"]})');
    }

    var filterProps = function filterProps(props) {
      return readonly ? Object.keys(props).reduce(function (accumulator, prop) {
        var _extends2;

        return isReadonly(prop) ? _extends({}, accumulator, (_extends2 = {}, _extends2[prop] = props[prop], _extends2)) : accumulator;
      }, {}) : props;
    };

    return function (DecoratedComponent) {
      return (function (_Component) {
        _inherits(ReduxForm, _Component);

        function ReduxForm() {
          _classCallCheck(this, ReduxForm);

          _Component.apply(this, arguments);
        }

        ReduxForm.prototype.componentWillMount = function componentWillMount() {
          var _props = this.props;
          var initialValues = _props.initialValues;
          var dispatch = _props.dispatch;
          var formName = _props.formName;
          var formKey = _props.formKey;
          // eslint-disable-line no-shadow
          if (initialValues) {
            var _ref = formKey ? _bindActionData2['default'](formActions, { form: formName, key: formKey }) : _bindActionData2['default'](formActions, { form: formName });

            var initialize = _ref.initialize;

            dispatch(initialize(initialValues));
          }
        };

        ReduxForm.prototype.render = function render() {
          var _this = this;

          // Read props
          var _props2 = this.props;
          var formName = _props2.formName;
          var form = _props2.form;
          var formKey = _props2.formKey;
          var dispatch = _props2.dispatch;

          var passableProps = _objectWithoutProperties(_props2, ['formName', 'form', 'formKey', 'dispatch']);

          // eslint-disable-line no-shadow
          if (!formName) {
            throw new Error('No form name given to redux-form. Must be passed to ' + 'connectReduxForm({form: [form name]}) or as a "formName" prop');
          }
          var subForm = getSubForm(form, formName, formKey);

          // Calculate calculable state
          var allValid = true;
          var allPristine = true;
          var values = fields.reduce(function (accumulator, field) {
            var _extends3;

            return _extends({}, accumulator, (_extends3 = {}, _extends3[field] = subForm[field] ? subForm[field].value : undefined, _extends3));
          }, {});

          // Create actions

          var _ref2 = formKey ? _bindActionData2['default'](formActions, { form: formName, key: formKey }) : _bindActionData2['default'](formActions, { form: formName });

          var blur = _ref2.blur;
          var change = _ref2.change;
          var focus = _ref2.focus;
          var initialize = _ref2.initialize;
          var reset = _ref2.reset;
          var startAsyncValidation = _ref2.startAsyncValidation;
          var startSubmit = _ref2.startSubmit;
          var stopAsyncValidation = _ref2.stopAsyncValidation;
          var stopSubmit = _ref2.stopSubmit;
          var touch = _ref2.touch;
          var untouch = _ref2.untouch;

          function runAsyncValidation() {
            dispatch(startAsyncValidation(formKey));
            var promise = asyncValidate(values, dispatch);
            if (!promise || typeof promise.then !== 'function') {
              throw new Error('asyncValidate function passed to reduxForm must return a promise!');
            }
            return promise.then(function (asyncErrors) {
              dispatch(stopAsyncValidation(asyncErrors));
              return isAsyncValid(asyncErrors);
            }, function (err) {
              dispatch(stopAsyncValidation({}));
              throw new Error('redux-form: Asynchronous validation failed: ' + err);
            });
          }

          var handleBlur = function handleBlur(name, value) {
            return function (event) {
              var fieldValue = getValue(value, event);
              var doBlur = _bindActionData2['default'](blur, { touch: touchOnBlur });
              dispatch(doBlur(name, fieldValue));
              if (asyncValidate && ~asyncBlurFields.indexOf(name)) {
                var _extends4;

                var syncError = syncValidate(_extends({}, values, (_extends4 = {}, _extends4[name] = fieldValue, _extends4)))[name];
                // only dispatch async call if all synchronous client-side validation passes for this field
                if (!syncError) {
                  runAsyncValidation();
                }
              }
            };
          };
          var handleFocus = function handleFocus(name) {
            return function () {
              dispatch(focus(name));
            };
          };
          var handleChange = function handleChange(name, value) {
            return function (event) {
              var doChange = _bindActionData2['default'](change, { touch: touchOnChange });
              dispatch(doChange(name, getValue(value, event)));
            };
          };
          var handleSubmit = function handleSubmit(submitOrEvent) {
            var createEventHandler = function createEventHandler(submit) {
              return function (event) {
                if (event && event.preventDefault) {
                  event.preventDefault();
                  event.stopPropagation();
                }
                var submitWithPromiseCheck = function submitWithPromiseCheck() {
                  var result = submit(values);
                  if (result && typeof result.then === 'function') {
                    // you're showing real promise, kid!
                    dispatch(startSubmit());
                    return result.then(function (submitResult) {
                      dispatch(stopSubmit());
                      return submitResult;
                    }, function (submitError) {
                      dispatch(stopSubmit(submitError));
                      return submitError;
                    });
                  }
                };
                dispatch(touch.apply(undefined, fields));
                if (allValid) {
                  if (asyncValidate) {
                    return runAsyncValidation().then(function (asyncValid) {
                      if (allValid && asyncValid) {
                        return submitWithPromiseCheck(values);
                      }
                    });
                  }
                  return submitWithPromiseCheck(values);
                }
              };
            };
            if (typeof submitOrEvent === 'function') {
              return createEventHandler(submitOrEvent);
            }
            var onSubmit = _this.props.onSubmit;

            if (!onSubmit) {
              throw new Error('You must either pass handleSubmit() an onSubmit function or pass onSubmit as a prop');
            }
            createEventHandler(onSubmit)(submitOrEvent /* is event */);
          };

          // Define fields
          var syncErrors = syncValidate(values);
          var allFields = fields.reduce(function (accumulator, name) {
            var _extends5;

            var field = subForm[name] || {};
            var pristine = _isPristine2['default'](field.value, field.initial);
            var error = syncErrors[name] || field.asyncError || field.submitError;
            var valid = _isValid2['default'](error);
            var fieldBlur = handleBlur(name);
            var fieldChange = handleChange(name);
            var fieldFocus = handleFocus(name);
            if (!valid) {
              allValid = false;
            }
            if (!pristine) {
              allPristine = false;
            }
            return _extends({}, accumulator, (_extends5 = {}, _extends5[name] = filterProps({
              active: subForm._active === name,
              checked: typeof field.value === 'boolean' ? field.value : undefined,
              dirty: !pristine,
              error: error,
              handleBlur: fieldBlur,
              handleChange: fieldChange,
              handleFocus: fieldFocus,
              invalid: !valid,
              name: name,
              onBlur: fieldBlur,
              onChange: fieldChange,
              onFocus: fieldFocus,
              onUpdate: fieldChange, // alias to support belle. https://github.com/nikgraf/belle/issues/58
              pristine: pristine,
              touched: field.touched,
              valid: valid,
              value: field.value,
              visited: field.visited
            }), _extends5));
          }, {});
          var formError = syncErrors._error || subForm._error;
          if (formError) {
            allValid = false;
          }

          // Return decorated component
          return React.createElement(DecoratedComponent, _extends({
            // State:
            active: subForm._active,
            asyncValidating: subForm._asyncValidating,
            dirty: !allPristine,
            error: formError,
            fields: allFields,
            formKey: formKey,
            invalid: !allValid,
            pristine: allPristine,
            submitting: subForm._submitting,
            valid: allValid,
            values: values,

            // Actions:
            asyncValidate: silenceEvents(runAsyncValidation),
            handleBlur: silenceEvents(handleBlur),
            handleChange: silenceEvents(handleChange),
            handleFocus: handleFocus,
            handleSubmit: silenceEvents(handleSubmit),
            initializeForm: silenceEvents(function (initialValues) {
              return dispatch(initialize(initialValues));
            }),
            resetForm: silenceEvents(function () {
              return dispatch(reset());
            }),
            touch: silenceEvents(function () {
              return dispatch(touch.apply(undefined, arguments));
            }),
            touchAll: silenceEvents(function () {
              return dispatch(touch.apply(undefined, fields));
            }),
            untouch: silenceEvents(function () {
              return dispatch(untouch.apply(undefined, arguments));
            }),
            untouchAll: silenceEvents(function () {
              return dispatch(untouch.apply(undefined, fields));
            }),

            // Other:
            dispatch: dispatch
          }, passableProps));
        };

        _createClass(ReduxForm, null, [{
          key: 'displayName',
          value: 'ReduxForm(' + _getDisplayName2['default'](DecoratedComponent) + ')',
          enumerable: true
        }, {
          key: 'DecoratedComponent',
          value: DecoratedComponent,
          enumerable: true
        }, {
          key: 'propTypes',
          value: {
            formName: PropTypes.string,
            formKey: PropTypes.string,
            form: PropTypes.object,
            onSubmit: PropTypes.func,
            dispatch: PropTypes.func.isRequired,
            initialValues: PropTypes.object
          },
          enumerable: true
        }, {
          key: 'defaultProps',
          value: {
            formName: formName
          },
          enumerable: true
        }]);

        return ReduxForm;
      })(Component);
    };
  };
}

module.exports = exports['default'];